<#
.synopsis
Configure the WinTrialLab cloud builder VM
.description
Perform deployment work on the system, including installing Powershell DSC prerequisite modules, creating the DSC MOF files, and actually running the configuration.
.parameter wtlRepoZipUri
The URI to the wintriallab repository zipfile generated by GitHub.
Note that we rely on GitHub's behavior of creating a zipfile with a single directory in the root, and all files in the repo added under that directory, but that we do not have to know the name of the directory beforehand.
.parameter eventLogName
The name of the event log to use during initial setup. Created if nonexistent. Note that DSC logs are sent to the normal event log, not the one named here.
.parameter eventLogSource
Arbitrary string to use as a name to use for the "source" of the event log entries we create.
#>
[CmdletBinding()] Param(
    [Parameter(Mandatory)] [string] $wtlRepoZipUri,
    [string] $eventLogName = "WinTrialLab",
    [string] $eventLogSource = "WinTrialLab-azure-deployInit.ps1"
)

<#
Development notes:

Do *not* use $PSScriptRoot to reference other files in the repository. This script is downloaded and run to clone the repo. Once the repo is cloned, reference files from $wtlCheckoutDir

Note that the DSC `Configuration` blocks can *not* be part of this file, even though it's dot-sourced and it looks like it could be added. This is because this script installs DSC resources. The DSC configurations load them via `Import-DscResource`, which is *not* a cmdlet, but is a dynamic keyword. Because it's a keyword, it isn't encapsulated in the `Configuration` and run when the configuration is invoked, but is actually run as soon as the script executes - and in this case, since this script is installing those DSC resources, that means it will run before the resources are installed, and therefore fail. Note also that even encapsulating the `Configuration` block in a scriptblock that is executed later will still result in an error. For these reasons, the DSC configuration itself must exist in a separate file which is called from this deployment script.

We go to some effort to make sure that this script doesn't have to know much about the wintriallab repository. In fact, it doesn't even need git installed, since we can just download the zipfile from GitHub. That said, we do rely on the structure of the zipfile that GitHub generates, as mentioned above.
#>

$ErrorActionPreference = "Stop"

## Helper functions

<#
.synopsis
Wrapper that writes to the event log but also to the screen
#>
function Write-EventLogWrapper {
    [cmdletbinding()] param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String] $message,
        [int] $eventId = 0,
        [ValidateSet("Error",'Warning','Information','SuccessAudit','FailureAudit')] $entryType = "Information"
    )
    if (-not (get-eventlog -logname * |? { $_.Log -eq $eventLogName })) {
        New-EventLog -Source $eventLogSource -LogName $eventLogName
    }
    $messagePlus = "$message`r`n`r`nScript: $($script:ScriptPath)`r`nUser: ${env:USERDOMAIN}\${env:USERNAME}"
    if ($messagePlus.length -gt 32766) {
        # Because Write-EventLog will die otherwise
        $messagePlus = $messagePlus.SubString(0,32766)
    }
    Write-Host -ForegroundColor Magenta "====Writing to $eventLogName event log===="
    # The event log tracks the date, but if viewing the output on the console, then this is helpful
    Write-Host -ForegroundColor DarkGray (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    write-host -ForegroundColor DarkGray "$messagePlus`r`n"
    Write-EventLog -LogName $eventLogName -Source $eventLogSource -EventID $eventId -EntryType $entryType -Message $MessagePlus
}

<#
.description
Get the PATH environment variables from Machine, User, and Process locations, and update the current Powershell process's PATH variable to contain all values from each of them. Call it after updating the Machine or User PATH value (which may happen automatically during say installing software) so you don't have to launch a new Powershell process to get them.
#>
function Update-EnvironmentPath {
    [CmdletBinding()] Param()
    $oldPath = $env:PATH
    $machinePath = [Environment]::GetEnvironmentVariable("PATH", "Machine") -split ";"
    $userPath = [Environment]::GetEnvironmentVariable("PATH", "User") -split ";"
    $processPath = [Environment]::GetEnvironmentVariable("PATH", "Process") -split ";"
    $env:PATH = ($machinePath + $userPath + $processPath | Select-Object -Unique) -join ";"
    Write-EventLogWrapper -message "Updated PATH environment variable`r`n`r`nNew value: $($env:PATH -replace ';', "`r`n")`r`n`r`nOld value: $($oldPath -replace ';', "`r`n")"
}

<#
.description
Wrap calls to external executables so that we can update the %PATH% first and check the exit code afterwards.
#>
function Invoke-PathExecutable {
    [CmdletBinding()] Param(
        [Parameter(Mandatory=$True)] [String] $commandLine
    )
    Update-EnvironmentPath
    try {
        Invoke-Expression $commandLine
        if ($LASTEXITCODE -ne 0) {
            throw "Command line '$commandLine' exited with code '$LASTEXITCODE'"
        } else {
            Write-EventLogWrapper -message "Command line '$commandLine' exited successfully with code '$LASTEXITCODE'"
        }
    } catch {
        Write-EventLogWrapper -message "When attempting to run command '$commandLine', got error '$_'"
        throw $_
    }
}

function New-TemporaryDirectory {
    $newTempDirPath = ""
    do {
        $newTempDirPath = Join-Path $env:TEMP (New-Guid | Select-Object -ExpandProperty Guid)
    } while (Test-Path -Path $newTempDirPath)
    New-Item -ItemType Directory -Path $newTempDirPath
}

# Guard against dot-sourcing
# If we are dot-sourced, define the functions above, but do not actually execute any deployment code
# This is a bit of a hack, but lets us define functions in this file that we want to use in dscConfiguration.ps1
if ($MyInvocation.InvocationName -ne '.') {
    Write-EventLogWrapper -message "Initializing the WinTrialLab cloud builder deployment..."
    Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine

    # Install DSC prerequisites
    Install-PackageProvider -Name NuGet -Force
    Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
    Install-Module -Name xHyper-V, cChoco

    # Download the wintriallab repo
    $wtlDlDir = New-TemporaryDirectory
    $wtlExtractDir = New-TemporaryDirectory
    $wtlZipFile = Join-Path -Path $wtlDlDir -ChildPath "wtl.zip"
    Invoke-WebRequest -Uri $wtlRepoZipUri -OutFile $wtlZipFile
    Expand-Archive -Path $wtlZipFile -DestinationPath $wtlExtractDir
    $wtlDir = Get-ChildItem -Path $wtlExtractDir | Select-Object -First 1
    Write-EventLogWrapper "wintriallab files and directories:`r`nwtlDlDir = '$wtlDlDir'`r`nwtlExtractDir = '$wtlExtractDir'`r`nwtlZipFile = '$wtlZipFile'`r`nwtlDir = '$wtlDir'`r`n"

    # Get the DSC configuration
    Write-EventLogWrapper "Invoking DSC configuration..."
    . "$wtlDir\azure\dscConfiguration.ps1"

    # Initialize DSC configuration
    $dscWorkDirBase = New-TemporaryDirectory | Select-Object -ExpandProperty FullName
    Write-EventLogWrapper -message "Using '$dscWorkDirBase' for DSC configurations"

    # Configure the Local Configuration Manager first
    $lcmWorkDir = Join-Path $dscWorkDirBase "LocalConfigurationManager"
    DSConfigure-LocalConfigurationManager -OutputPath $lcmWorkDir | Write-EventLogWrapper
    Set-DscLocalConfigurationManager -Path $lcmWorkDir | Write-EventLogWrapper

    # Now run the WinTrialLab DSC configuration
    $wtlWorkDir = Join-Path $dscWorkDirBase "WinTrialLab"
    DSConfigure-WinTrialBuilder -OutputPath $wtlWorkDir | Write-EventLogWrapper
    Start-DscConfiguration -Path $wtlWorkDir | Write-EventLogWrapper
}
